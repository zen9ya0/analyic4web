import hashlib
import os
import re
import math
import pefile
import requests
import magic
import argparse
import sys
import json
import configparser

def analyze_file(file_path):
    results = {}
    
    # 檢查檔案是否存在
    if not os.path.exists(file_path):
        return {"error": "檔案不存在"}
    
    # 1. 檢測檔案類型
    try:
        file_type = magic.from_file(file_path)
        mime_type = magic.from_file(file_path, mime=True)
        results['file_type'] = file_type
        results['mime_type'] = mime_type
    except Exception as e:
        results['file_type_error'] = str(e)
    
    # 2. 計算檔案雜湊值
    with open(file_path, 'rb') as f:
        content = f.read()
        results['md5'] = hashlib.md5(content).hexdigest()
        results['sha1'] = hashlib.sha1(content).hexdigest()
        results['sha256'] = hashlib.sha256(content).hexdigest()
    
    # 3. 檢查檔案大小
    results['file_size'] = os.path.getsize(file_path)
    
    # 4. 提取字串並尋找可疑內容
    strings = re.findall(b"[\\x20-\\x7e]{5,}", content)
    suspicious_strings = []
    
    # 尋找可疑 URL、IP 位址和命令
    for s in strings:
        string = s.decode('utf-8', errors='ignore')
        if re.search(r'https?://|www\.|\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|cmd\.exe|powershell|regsvr32|rundll32|cscript|wscript|schtasks|certutil', string):
            suspicious_strings.append(string)
    
    results['suspicious_strings'] = suspicious_strings
    
    # 5. 計算熵值
    entropy = calculate_entropy(content)
    results['entropy'] = entropy
    
    # 6. 如果是 PE 檔案，分析導入函數
    if 'PE32' in file_type or 'PE32+' in file_type:
        try:
            pe = pefile.PE(file_path)
            imports = []
            suspicious_imports = []
            
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode()
                for imp in entry.imports:
                    if imp.name:
                        imp_name = imp.name.decode()
                        imports.append(f"{dll_name}: {imp_name}")
                        
                        # 檢查可疑導入函數
                        suspicious_apis = ['VirtualAlloc', 'WriteProcessMemory', 'CreateRemoteThread', 
                                          'ReadProcessMemory', 'CreateProcess', 'WinExec', 
                                          'ShellExecute', 'HttpSendRequest', 'InternetOpen', 
                                          'InternetConnect', 'InternetOpenUrl', 'URLDownloadToFile', 
                                          'RegCreateKey', 'RegSetValue']
                        
                        if any(api in imp_name for api in suspicious_apis):
                            suspicious_imports.append(f"{dll_name}: {imp_name}")
            
            results['imports'] = imports
            results['suspicious_imports'] = suspicious_imports
            results['is_signed'] = check_signature(pe)
            
            # 檢查PE檔案區段
            sections = []
            suspicious_sections = False
            for section in pe.sections:
                section_name = section.Name.strip(b'\x00').decode('utf-8', errors='ignore')
                section_entropy = calculate_entropy(section.get_data())
                section_info = {
                    'name': section_name,
                    'virtual_address': hex(section.VirtualAddress),
                    'virtual_size': hex(section.Misc_VirtualSize),
                    'raw_size': hex(section.SizeOfRawData),
                    'entropy': section_entropy
                }
                sections.append(section_info)
                
                # 檢查可疑區段名稱或高熵值區段
                if section_entropy > 7.0 or section_name not in ['.text', '.data', '.rdata', '.idata', '.pdata', '.rsrc', '.reloc']:
                    suspicious_sections = True
            
            results['sections'] = sections
            results['suspicious_sections'] = suspicious_sections
            
        except Exception as e:
            results['pe_analysis_error'] = str(e)
    
    # 7. 評估檔案的可疑程度
    suspicion_score = calculate_suspicion_score(results)
    results['suspicion_score'] = suspicion_score
    
    return results

def calculate_entropy(data):
    if not data:
        return 0
    
    entropy = 0
    byte_count = {}
    for byte in data:
        byte_count[byte] = byte_count.get(byte, 0) + 1
    
    for count in byte_count.values():
        p_x = float(count) / len(data)
        entropy += - p_x * math.log(p_x, 2)
    
    return entropy

def check_signature(pe):
    # 簡單檢查是否有數位簽章
    return hasattr(pe, 'DIRECTORY_ENTRY_SECURITY') and pe.DIRECTORY_ENTRY_SECURITY.VirtualAddress != 0

def calculate_suspicion_score(results):
    score = 0
    
    # 基於熵值評分
    if results.get('entropy', 0) > 7.0:
        score += 20
    elif results.get('entropy', 0) > 6.5:
        score += 10
    
    # 基於可疑字串數量評分
    susp_strings_count = len(results.get('suspicious_strings', []))
    if susp_strings_count > 10:
        score += 20
    elif susp_strings_count > 5:
        score += 10
    elif susp_strings_count > 0:
        score += 5
    
    # 基於可疑導入函數評分
    if 'suspicious_imports' in results:
        if len(results['suspicious_imports']) > 5:
            score += 25
        elif len(results['suspicious_imports']) > 2:
            score += 15
        elif len(results['suspicious_imports']) > 0:
            score += 5
    
    # 基於檔案類型評分
    if results.get('file_type', ''):
        if 'executable' in results['file_type'].lower() and 'signed' not in results:
            score += 10
        if 'script' in results['file_type'].lower():
            score += 5
    
    # 基於PE區段評分
    if results.get('suspicious_sections', False):
        score += 15
    
    # 未簽署的可執行檔
    if results.get('is_signed', None) is False and 'PE32' in results.get('file_type', ''):
        score += 10
    
    return min(score, 100)  # 上限為100分

# 從配置檔讀取 VirusTotal API 金鑰
def get_virustotal_api_key():
    config_path = os.path.join('config', 'config.ini')
    
    # 檢查配置目錄是否存在，如果不存在則創建
    if not os.path.exists('config'):
        os.makedirs('config')
    
    # 檢查配置檔是否存在
    if not os.path.exists(config_path):
        # 創建一個預設的配置檔
        config = configparser.ConfigParser()
        config['VIRUSTOTAL'] = {'VT_API_KEY': ''}
        with open(config_path, 'w') as configfile:
            config.write(configfile)
        return None
    
    # 讀取配置檔
    config = configparser.ConfigParser()
    config.read(config_path)
    
    # 檢查是否有 VirusTotal API 金鑰
    if 'VIRUSTOTAL' in config and 'VT_API_KEY' in config['VIRUSTOTAL']:
        api_key = config['VIRUSTOTAL']['VT_API_KEY'].strip()
        if api_key:
            return api_key
    
    return None

# 使用 VirusTotal API 檢查雜湊值
def check_virustotal(file_hash, api_key=None):
    if not api_key:
        api_key = get_virustotal_api_key()
        
    if not api_key:
        return {'status': 'No VirusTotal API key found in config/config.ini'}
    
    url = f'https://www.virustotal.com/vtapi/v2/file/report'
    params = {'apikey': api_key, 'resource': file_hash}
    
    try:
        response = requests.get(url, params=params)
        
        if response.status_code == 200:
            result = response.json()
            if result['response_code'] == 1:
                return {
                    'detection_ratio': f"{result['positives']}/{result['total']}",
                    'scan_date': result['scan_date'],
                    'permalink': result.get('permalink', 'N/A')
                }
        return {'status': 'File not found in VirusTotal database'}
    except Exception as e:
        return {'status': f'Error checking VirusTotal: {str(e)}'}

def main():
    parser = argparse.ArgumentParser(description='快速惡意程式檔案分析工具')
    parser.add_argument('file_path', help='要分析的檔案路徑')
    parser.add_argument('--vt-check', '-vt', action='store_true', help='檢查 VirusTotal (使用 config/config.ini 中的 API 金鑰)')
    parser.add_argument('--output', '-o', help='輸出結果到JSON檔案')
    parser.add_argument('--verbose', '-v', action='store_true', help='顯示詳細資訊')
    
    args = parser.parse_args()
    
    results = analyze_file(args.file_path)
    
    # 如果需要檢查 VirusTotal
    if args.vt_check:
        vt_results = check_virustotal(results['sha256'])
        results['virustotal'] = vt_results
    
    # 輸出結果
    if args.verbose:
        # 詳細模式，輸出完整結果
        print(json.dumps(results, indent=2, ensure_ascii=False))
    else:
        # 簡潔模式，只輸出重要資訊
        summary = {
            'file_path': args.file_path,
            'file_type': results.get('file_type', 'Unknown'),
            'file_size': results.get('file_size', 0),
            'md5': results.get('md5', ''),
            'sha256': results.get('sha256', ''),
            'entropy': results.get('entropy', 0),
            'suspicious_strings_count': len(results.get('suspicious_strings', [])),
            'suspicious_imports_count': len(results.get('suspicious_imports', [])) if 'suspicious_imports' in results else 0,
            'suspicion_score': results.get('suspicion_score', 0),
            'verdict': '可能為惡意程式' if results.get('suspicion_score', 0) > 50 else '可能為正常檔案'
        }
        
        if 'virustotal' in results:
            summary['virustotal'] = results['virustotal']
        
        print("\n=== 檔案分析結果摘要 ===")
        print(f"檔案路徑: {summary['file_path']}")
        print(f"檔案類型: {summary['file_type']}")
        print(f"檔案大小: {summary['file_size']} 位元組")
        print(f"MD5: {summary['md5']}")
        print(f"SHA256: {summary['sha256']}")
        print(f"熵值: {summary['entropy']:.4f}")
        print(f"可疑字串數量: {summary['suspicious_strings_count']}")
        print(f"可疑導入函數數量: {summary['suspicious_imports_count']}")
        print(f"可疑程度分數: {summary['suspicion_score']}/100")
        print(f"初步判斷: {summary['verdict']}")
        
        if 'virustotal' in summary:
            vt = summary['virustotal']
            if 'detection_ratio' in vt:
                print(f"VirusTotal 結果: {vt['detection_ratio']} 引擎檢出")
                print(f"VirusTotal 連結: {vt.get('permalink', 'N/A')}")
            else:
                print(f"VirusTotal 結果: {vt.get('status', 'Unknown')}")
    
    # 如果指定輸出檔案，則寫入 JSON
    if args.output:
        with open(args.output, 'w', encoding='utf-8') as f:
            json.dump(results, f, indent=2, ensure_ascii=False)
        print(f"\n完整分析結果已儲存至: {args.output}")

if __name__ == "__main__":
    main()